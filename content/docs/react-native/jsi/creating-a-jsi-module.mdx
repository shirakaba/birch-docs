---
title: Creating a JSI module
description: Boilerplate for creating a simple JSI module
icon: Blocks
---

# About JSI modules

JSI, TurboModules, Codegen, and New Architecture are often talked about in the same breath as if they're all part of the same thing, but in actuality, they're not. You can create JSI-based TurboModules without Codegen, and they can run on Old Architecture, at that.

I've never got on well with the official guides for [creating a TurboModule](https://reactnative.dev/docs/turbo-native-modules-introduction). The Codegen step has a massive surface area for failure, and trying to hide all that complexity away using a CLI tool just prevents developers from properly mastering the fundamentals.

I prefer to build my JSI modules from zero. No CLI tool, no Codegen, no unknowns. It only takes a few files.

## What do you mean by "JSI module"?

I'm avoiding saying "TurboModule" because in Old Architecture, native modules seem to be registered into both `NativeModules` and `TurboModuleRegistry`. In other words, **both** of these calls return a module:

```ts
import { NativeModules, TurboModuleRegistry } from "react-native";

// ① TurboModule
const MyModule = TurboModuleRegistry.get("MyModule");

// ② Legacy native module
const { MyModule } = NativeModules;
```

{/* As the migration from Old Architecture to New Architecture was a gradual one, there is a certain degree of support for both TurboModules and legacy modules (I'm not sure whether to call them [Modules](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/vnext/Microsoft.ReactNative.Cxx/ModuleRegistration.cpp#L23), [Native Modules](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/vnext/Shared/NativeModuleProvider.h#L34), or [Attributed Modules](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/vnext/Microsoft.ReactNative.Cxx/ModuleRegistration.cpp#L18)), even in Old Architecture. */}

To add to the confusion, you can write a TurboModule that uses a _mixture_ of both the legacy Batched Bridge APIs (e.g. `RCT_EXPORT_METHOD`) and JSI code (by grabbing the JSI Runtime from the Bridge, as you'll see below). React Native Windows makes it particularly clear that they're not genetically that different, as you can make a module be turbo or non-turbo simply by [flipping a boolean](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/packages/integration-test-app/windows/integrationtest/ReactPackageProvider.cpp#L15) when initialising it.

{/* So, to clarify: */}

{/* - TurboModules don't have to extend a Spec; that's just a Codegen thing. */}
{/* - They're not New Architecture-only. */}

{/* I think the main distinction between them is that TurboModules are lazy-initialised, while NativeModules are not. */}

## iOS (and macOS)

This boilerplate consists of five hand-written files:

1. The native module:
   - `MyModule.ts`: The TypeScript interface (and installation command) for the native module.
   - `MyModule.{h,mm}`: The native module itself.

2. The Host Object:
   - `MyHostObject.{h,mm}`: An example `jsi::HostObject` that implements a `makeUUID()` function.

For the `.h` and `.mm` files, you need to manually add them to your Xcode project.

### ① The native module

#### `MyModule.ts`

```ts
import { type TurboModule, TurboModuleRegistry } from "react-native";

declare global {
  /** Will be defined once you've called install(). */
  let MyHostObject: MyHostObjectType | undefined;
}

interface MyHostObjectType {
  /** Returns a UUID. */
  makeUUID(): string;
}

/**
 * A convenience function for looking up MyModule and calling install() on it.
 *
 * Call this in your entrypoint file in order to populate global.MyHostObject.
 */
export function install() {
  const turboModule = TurboModuleRegistry.get<MyModule>("MyModule");
  if (!turboModule) {
    throw new Error(`Failed to find "MyModule" in TurboModuleRegistry.`);
  }
  turboModule.install();
}

interface MyModule extends TurboModule {
  install(): void;
}
```

#### `MyModule.h`

```cpp
#import <React/RCTBridgeModule.h>

@interface MyModule : NSObject <RCTBridgeModule>
@end
```

#### `MyModule.mm`

```objective-cpp
#import <React/RCTBridge+Private.h>
#import <jsi/jsi.h>
#import "MyModule.h"
#import "MyHostObject.h"

using namespace facebook;

@implementation MyModule

RCT_EXPORT_MODULE()

+ (BOOL)requiresMainQueueSetup
{
  return YES;
}

// Installing the bindings as a blocking synchronous method avoids a race
// condition when hot module reloading (that crashes the app).
// https://github.com/margelo/react-native-quick-crypto/blob/main/ios/QuickCryptoModule.mm
RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(install) {
  NSLog(@"Installing JSI bindings for MyModule...");

  RCTBridge* bridge = [RCTBridge currentBridge];
  RCTCxxBridge* cxxBridge = (RCTCxxBridge*)bridge;
  if (cxxBridge == nil) {
    return @false;
  }

  jsi::Runtime *runtime = (jsi::Runtime *)cxxBridge.runtime;
  if (!runtime) {
    return @false;
  }

  runtime->global().setProperty(
    *runtime,
    "MyHostObject",
    jsi::Object::createFromHostObject(*runtime, std::make_unique<MyHostObject>())
  );

  NSLog(@"... Successfully installed JSI bindings for MyModule!");
  return @true;
}

@end
```

### ② The JSI Host Object

#### `MyHostObject.h`

```cpp
#import <jsi/jsi.h>

using namespace facebook;

class JSI_EXPORT MyHostObject : public jsi::HostObject {
  public:
    MyHostObject();

  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name) override;
};
```

#### `MyHostObject.cpp`

```objective-cpp
#import <Foundation/Foundation.h>
#import <React/RCTBridge+Private.h>
#import <ReactCommon/RCTTurboModule.h>
#import <React/RCTBundleURLProvider.h>
#import "MyHostObject.h"

MyHostObject::MyHostObject(){}

jsi::Value MyHostObject::get(jsi::Runtime &rt, const jsi::PropNameID &propName)
{
  std::string name = propName.utf8(rt);
  if(name == "makeUUID"){
    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, name),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisValue, const jsi::Value *arguments, size_t) -> jsi::Value {
        NSString *uuidString = [[NSUUID UUID] UUIDString];
        return jsi::String::createFromUtf8(runtime, [uuidString UTF8String]);
      }
    );
  }

  return jsi::Value::undefined();
}
```

# Android

TODO

# Windows (UWP)

Old Arch libraries are initialised as follows:

```sh
npx react-native init-windows --logging --overwrite --template old/uwp-cpp-lib --name MyModule
```

This boilerplate consists of the following files:

1. The native module:
   - `MyModule.ts`: The TypeScript interface (and installation command) for the native module.
   - `ReactPackageProvider.{h,cpp}`: Just some boilerplate that is generated by `react-native init-windows`. No need to change.
   - `ReactNativeModule.h`: Also generated by `react-native init-windows`, the main file that you'll be editing.
2. The Host Object:
   - `MyHostObject.h`: An example `jsi::HostObject` that implements a `makeUUID()` function.

Remember to add `MyHostObject.h` to the Visual Studio project. I usually do this by directly editing `MyModule.vcxproj` and `MyModule.vcxproj.filters`.

### ① The native module

This is the exact same as for the iOS (and macOS) example.

#### `MyModule.ts`

```ts
import { type TurboModule, TurboModuleRegistry } from "react-native";

declare global {
  /** Will be defined once you've called install(). */
  let MyHostObject: MyHostObjectType | undefined;
}

interface MyHostObjectType {
  /** Returns a UUID. */
  makeUUID(): string;
}

/**
 * A convenience function for looking up MyModule and calling install() on it.
 *
 * Call this in your entrypoint file in order to populate global.MyHostObject.
 */
export function install() {
  const turboModule = TurboModuleRegistry.get<MyModule>("MyModule");
  if (!turboModule) {
    throw new Error(`Failed to find "MyModule" in TurboModuleRegistry.`);
  }
  turboModule.install();
}

interface MyModule extends TurboModule {
  install(): void;
}
```

#### `ReactPackageProvider.h`

```cpp
#pragma once
#include "ReactPackageProvider.g.h"

using namespace winrt::Microsoft::ReactNative;

namespace winrt::MyModule::implementation
{
struct ReactPackageProvider : ReactPackageProviderT<ReactPackageProvider>
{
  ReactPackageProvider() = default;

  void CreatePackage(IReactPackageBuilder const &packageBuilder) noexcept;
};
} // namespace winrt::MyModule::implementation

namespace winrt::MyModule::factory_implementation
{

struct ReactPackageProvider : ReactPackageProviderT<ReactPackageProvider, implementation::ReactPackageProvider>
{
};

} // namespace winrt::MyModule::factory_implementation
```

#### `ReactPackageProvider.cpp`

```cpp
#include "pch.h"
#include "ReactPackageProvider.h"
#if __has_include("ReactPackageProvider.g.cpp")
#include "ReactPackageProvider.g.cpp"
#endif

#include "ReactNativeModule.h"

using namespace winrt::Microsoft::ReactNative;

namespace winrt::MyModule::implementation
{

void ReactPackageProvider::CreatePackage(IReactPackageBuilder const &packageBuilder) noexcept
{
  AddAttributedModules(packageBuilder, true);
}

} // namespace winrt::MyModule::implementation
```

#### `ReactNativeModule.h`

```cpp
#pragma once

#include <JSI/JsiAbiApi.h>
#include <JSI/JsiApiContext.h>
#include <ReactCommon/TurboModule.h>
#include <TurboModuleProvider.h>
#include <Windows.h>
#include <jsi/jsi.h>
#include <winrt/Microsoft.ReactNative.h>
#include <winrt/Windows.Foundation.h>
#include "MyHostObject.h"
#include "JSValue.h"
#include "NativeModules.h"

using namespace winrt::Microsoft::ReactNative;

namespace winrt::MyModule
{

REACT_MODULE(ReactNativeModule, L"MyModule")
struct ReactNativeModule
{
  // See https://microsoft.github.io/react-native-windows/docs/native-modules
  // for details on writing native modules

  REACT_INIT(Initialize)
  void Initialize(ReactContext const &reactContext) noexcept
  {
    m_reactContext = reactContext;

    ExecuteJsi(
      reactContext,
      [reactContext](jsi::Runtime &rt)
      {
        // From React Native Windows v0.74, it simplifies from
        // `reactContext.JSDispatcher().Handle()` to just `reactContext`.
        auto callInvoker = winrt::Microsoft::ReactNative::MakeAbiCallInvoker(reactContext.JSDispatcher().Handle());

        rt.global().setProperty(
          rt,
          "MyHostObject",
          jsi::Object::createFromHostObject(rt, std::make_shared<MyHostObject>(callInvoker))
        );
      }
    );
  }

 private:
  ReactContext m_reactContext{nullptr};
};

} // namespace winrt::MyModule
```

### ② The JSI Host Object

#### `MyHostObject.h`

```cpp
#pragma once

#include <JSI/JsiApiContext.h>
#include <ReactCommon/TurboModule.h>
#include <ReactCommon/TurboModuleUtils.h>
#include <Windows.h>
#include <jsi/jsi.h>
#include <winrt/Windows.Foundation.h>
#include <string>
#include "JSValue.h"
#include "NativeModules.h"

using namespace winrt::Microsoft::ReactNative;
using namespace winrt::Windows::Foundation;
using namespace facebook;

namespace winrt::MyModule
{
/// The library of platform-agnostic APIs.
class MyHostObject : public jsi::HostObject
{
 public:
  MyHostObject(std::shared_ptr<react::CallInvoker> jsInvoker) : jsi::HostObject()
  {
    m_jsInvoker = jsInvoker;
  }

 private:
  std::shared_ptr<react::CallInvoker> m_jsInvoker{nullptr};

 public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override
  {
    std::string name = propName.utf8(rt);

    if (name == "makeUUID")
    {
      return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, name),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &, const jsi::Value *, size_t) -> jsi::Value
        {
          winrt::guid newGuid = winrt::Windows::Foundation::GuidHelper::CreateNewGuid();
          std::string guidStr = winrt::to_string(winrt::to_hstring(newGuid));

          // Remove the surrounding braces.
          if (!guidStr.empty() && guidStr.front() == '{' && guidStr.back() == '}')
          {
            guidStr = guidStr.substr(1, guidStr.size() - 2);
          }

          return jsi::String::createFromAscii(rt, guidStr);
        }
      );
    }

    return jsi::Value::undefined();
  }

  void set(jsi::Runtime &, const jsi::PropNameID &, const jsi::Value &) override {}
};

} // namespace winrt::MyModule
```
