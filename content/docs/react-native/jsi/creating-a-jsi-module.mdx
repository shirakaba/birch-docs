---
title: Creating a JSI module
description: Boilerplate for creating a simple JSI module
icon: Blocks
---

# About JSI modules

JSI, TurboModules, Codegen, and New Architecture are often talked about in the same breath as if they're all part of the same thing, but in actuality, they're not. You can create JSI-based TurboModules without Codegen, and they can run on Old Architecture, at that.

I've never got on well with the official guides for [creating a TurboModule](https://reactnative.dev/docs/turbo-native-modules-introduction). The Codegen step has a massive surface area for failure, and trying to hide all that complexity away using a CLI tool just prevents developers from properly mastering the fundamentals.

I prefer to build my JSI modules from zero. No CLI tool, no Codegen, no unknowns. It only takes a few files.

## What do you mean by "JSI module"?

I'm avoiding saying "TurboModule" because in Old Architecture, native modules seem to be registered into both `NativeModules` and `TurboModuleRegistry`. In other words, **both** of these calls return a module:

```ts
import { NativeModules, TurboModuleRegistry } from "react-native";

// ① TurboModule
const MyModule = TurboModuleRegistry.get("MyModule");

// ② Legacy native module
const { MyModule } = NativeModules;
```

{/* As the migration from Old Architecture to New Architecture was a gradual one, there is a certain degree of support for both TurboModules and legacy modules (I'm not sure whether to call them [Modules](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/vnext/Microsoft.ReactNative.Cxx/ModuleRegistration.cpp#L23), [Native Modules](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/vnext/Shared/NativeModuleProvider.h#L34), or [Attributed Modules](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/vnext/Microsoft.ReactNative.Cxx/ModuleRegistration.cpp#L18)), even in Old Architecture. */}

To add to the confusion, you can write a TurboModule that uses a _mixture_ of both the legacy Batched Bridge APIs (e.g. `RCT_EXPORT_METHOD`) and JSI code (by grabbing the JSI Runtime from the Bridge, as you'll see below). React Native Windows makes it particularly clear that they're not genetically that different, as you can make a module be turbo or non-turbo simply by [flipping a boolean](https://github.com/microsoft/react-native-windows/blob/614427434ed1c122d4b10af098d2b50740e83f73/packages/integration-test-app/windows/integrationtest/ReactPackageProvider.cpp#L15) when initialising it.

{/* So, to clarify: */}

{/* - TurboModules don't have to extend a Spec; that's just a Codegen thing. */}
{/* - They're not New Architecture-only. */}

{/* I think the main distinction between them is that TurboModules are lazy-initialised, while NativeModules are not. */}

## iOS (and macOS)

### ① The native module

#### `MyModule.ts`

This file provides the TypeScript interface, and an installation command, for the native module.

```ts
import { type TurboModule, TurboModuleRegistry } from "react-native";

declare global {
  /** Will be defined once you've called install(). */
  let MyHostObject: MyHostObjectType | undefined;
}

interface MyHostObjectType {
  /** Returns a UUID. */
  makeUUID(): string;
}

/**
 * A convenience function for looking up MyModule and calling install() on it.
 *
 * Call this in your entrypoint file in order to populate global.MyHostObject.
 */
export function install() {
  const turboModule = TurboModuleRegistry.get<MyModule>("MyModule");
  if (!turboModule) {
    throw new Error(`Failed to find "MyModule" in TurboModuleRegistry.`);
  }
  turboModule.install();
}

interface MyModule extends TurboModule {
  install(): void;
}
```

#### `MyModule.h`

This is the Objective-C++ **header** for the native module.

```cpp
#import <React/RCTBridgeModule.h>

@interface MyModule : NSObject <RCTBridgeModule>
@end
```

Remember to add this to your Xcode project!

#### `MyModule.mm`

This is the Objective-C++ **implementation** for the native module.

```objective-cpp
#import <React/RCTBridge+Private.h>
#import <jsi/jsi.h>
#import "MyModule.h"
#import "MyHostObject.h"

using namespace facebook;

@implementation MyModule

RCT_EXPORT_MODULE()

+ (BOOL)requiresMainQueueSetup
{
  return YES;
}

// Installing the bindings as a blocking synchronous method avoids a race
// condition when hot module reloading (that crashes the app).
// https://github.com/margelo/react-native-quick-crypto/blob/main/ios/QuickCryptoModule.mm
RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(install) {
  NSLog(@"Installing JSI bindings for MyModule...");

  RCTBridge* bridge = [RCTBridge currentBridge];
  RCTCxxBridge* cxxBridge = (RCTCxxBridge*)bridge;
  if (cxxBridge == nil) {
    return @false;
  }

  jsi::Runtime *runtime = (jsi::Runtime *)cxxBridge.runtime;
  if (!runtime) {
    return @false;
  }

  runtime->global().setProperty(
    *runtime,
    "MyHostObject",
    jsi::Object::createFromHostObject(*runtime, std::make_unique<MyHostObject>())
  );

  NSLog(@"... Successfully installed JSI bindings for MyModule!");
  return @true;
}

@end
```

Remember to add this to your Xcode project!

### ② The JSI Host Object

#### `MyHostObject.h`

This is the Objective-C++ **header** for the `jsi::HostObject`.

```cpp
#import <jsi/jsi.h>

using namespace facebook;

class JSI_EXPORT MyHostObject : public jsi::HostObject {
  public:
    MyHostObject();

  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name) override;
};
```

Remember to add this to your Xcode project!

#### `MyHostObject.mm`

This is the Objective-C++ **implementation** for the `jsi::HostObject`. It implements a `makeUUID()` function.

```objective-cpp
#import <Foundation/Foundation.h>
#import <React/RCTBridge+Private.h>
#import <ReactCommon/RCTTurboModule.h>
#import <React/RCTBundleURLProvider.h>
#import "MyHostObject.h"

MyHostObject::MyHostObject(){}

jsi::Value MyHostObject::get(jsi::Runtime &rt, const jsi::PropNameID &propName)
{
  std::string name = propName.utf8(rt);
  if(name == "makeUUID"){
    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, name),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisValue, const jsi::Value *arguments, size_t) -> jsi::Value {
        NSString *uuidString = [[NSUUID UUID] UUIDString];
        return jsi::String::createFromUtf8(runtime, [uuidString UTF8String]);
      }
    );
  }

  return jsi::Value::undefined();
}
```

Remember to add this to your Xcode project!

# Android

TODO

# Windows (Old Arch)

First, initialise an Old Arch library as follows:

```sh
npx react-native init-windows --logging --overwrite --template old/uwp-cpp-lib --name MyModule
```

This boilerplate will carry on from that step.

### ① The native module

This is the exact same as for the iOS (and macOS) example.

#### `MyModule.ts`

This file provides the TypeScript interface, and an installation command, for the native module.

```ts
import { type TurboModule, TurboModuleRegistry } from "react-native";

declare global {
  /** Will be defined once you've called install(). */
  let MyHostObject: MyHostObjectType | undefined;
}

interface MyHostObjectType {
  /** Returns a UUID. */
  makeUUID(): string;
}

/**
 * A convenience function for looking up MyModule and calling install() on it.
 *
 * Call this in your entrypoint file in order to populate global.MyHostObject.
 */
export function install() {
  const turboModule = TurboModuleRegistry.get<MyModule>("MyModule");
  if (!turboModule) {
    throw new Error(`Failed to find "MyModule" in TurboModuleRegistry.`);
  }
  turboModule.install();
}

interface MyModule extends TurboModule {
  install(): void;
}
```

#### `ReactPackageProvider.{h,cpp}`

These two C++ files implement the native module's package provider. We'll take the default [`ReactPackagerProvider.h`](https://github.com/microsoft/react-native-windows/blob/d1f46f7a19b38d8ea60fcb697dae154849ec7520/vnext/templates/cpp-lib/windows/MyLib/ReactPackageProvider.h) and [`ReactPackagerProvider.cpp`](https://github.com/microsoft/react-native-windows/blob/d1f46f7a19b38d8ea60fcb697dae154849ec7520/vnext/templates/cpp-lib/windows/MyLib/ReactPackageProvider.cpp) files created by `react-native init-windows`; no need to change them.

#### `ReactNativeModule.h`

This is the C++/WinRT **header** for the native module. We'll make just some small additions to the default [`ReactNativeModule.h`](https://github.com/microsoft/react-native-windows/blob/d1f46f7a19b38d8ea60fcb697dae154849ec7520/vnext/templates/cpp-lib/windows/MyLib/MyLib.h) file created by `react-native init-windows`. Upon initialisation, we'll make our native module set up an instance of `MyHostObject` on the global.

```diff
  #pragma once

+ // TODO: Investigate which of these headers can be removed.
+ #include <JSI/JsiAbiApi.h>
+ #include <JSI/JsiApiContext.h>
+ #include <ReactCommon/TurboModule.h>
+ #include <TurboModuleProvider.h>
+ #include <Windows.h>
+ #include <jsi/jsi.h>
+ #include <winrt/Microsoft.ReactNative.h>
+ #include <winrt/Windows.Foundation.h>
+ #include "JSValue.h"
  #include "NativeModules.h"
+ #include "MyHostObject.h"

  using namespace winrt::Microsoft::ReactNative;

  namespace winrt::MyModule
  {

  REACT_MODULE(ReactNativeModule, L"MyModule")
  struct ReactNativeModule
  {
    // See https://microsoft.github.io/react-native-windows/docs/native-modules
    // for details on writing native modules

    REACT_INIT(Initialize)
    void Initialize(ReactContext const &reactContext) noexcept
    {
      m_reactContext = reactContext;

+     ExecuteJsi(
+       reactContext,
+       [reactContext](jsi::Runtime &rt)
+       {
+         auto callInvoker = winrt::Microsoft::ReactNative::MakeAbiCallInvoker(reactContext.JSDispatcher().Handle());
+
+         rt.global().setProperty(
+           rt,
+           "MyHostObject",
+           jsi::Object::createFromHostObject(rt, std::make_shared<MyHostObject>(callInvoker))
+         );
+       }
+     );
    }

   private:
    ReactContext m_reactContext{nullptr};
  };

  } // namespace winrt::MyModule
```

### ② The JSI Host Object

#### `MyHostObject.h`

This is the C++/WinRT **implementation** for the `jsi::HostObject`. It implements a `makeUUID()` function.

```cpp
#pragma once

#include <JSI/JsiApiContext.h>
#include <ReactCommon/TurboModule.h>
#include <ReactCommon/TurboModuleUtils.h>
#include <Windows.h>
#include <jsi/jsi.h>
#include <winrt/Windows.Foundation.h>
#include <string>
#include "JSValue.h"
#include "NativeModules.h"

using namespace winrt::Microsoft::ReactNative;
using namespace winrt::Windows::Foundation;
using namespace facebook;

namespace winrt::MyModule
{
/// The library of platform-agnostic APIs.
class MyHostObject : public jsi::HostObject
{
 public:
  MyHostObject(std::shared_ptr<react::CallInvoker> jsInvoker) : jsi::HostObject()
  {
    m_jsInvoker = jsInvoker;
  }

 private:
  std::shared_ptr<react::CallInvoker> m_jsInvoker{nullptr};

 public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override
  {
    std::string name = propName.utf8(rt);

    if (name == "makeUUID")
    {
      return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, name),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &, const jsi::Value *, size_t) -> jsi::Value
        {
          winrt::guid newGuid = winrt::Windows::Foundation::GuidHelper::CreateNewGuid();
          std::string guidStr = winrt::to_string(winrt::to_hstring(newGuid));

          // Remove the surrounding braces.
          if (!guidStr.empty() && guidStr.front() == '{' && guidStr.back() == '}')
          {
            guidStr = guidStr.substr(1, guidStr.size() - 2);
          }

          return jsi::String::createFromAscii(rt, guidStr);
        }
      );
    }

    return jsi::Value::undefined();
  }

  void set(jsi::Runtime &, const jsi::PropNameID &, const jsi::Value &) override {}
};

} // namespace winrt::MyModule
```

Remember to add `MyHostObject.h` to the Visual Studio project. I usually do this by directly editing `MyModule.vcxproj` and `MyModule.vcxproj.filters`.
